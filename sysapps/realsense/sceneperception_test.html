<html>
  <head>
    <title>ScenePerception Test</title>
  </head>
  <body>
    <p id='quality'>Quality: </p>
	<p id='accuracy'>Accuracy: </p>
	<div style='margin-bottom:23px;'>
		<button id='start'>Start</button>
		<button id='stop'>Stop</button>
		<button id='reset'>Reset</button>
		<button id='enableTracking'>Enable Tracking</button>
		<button id='disableTracking'>Disable Tracking</button>
		<button id='enableMeshing'>Enable Meshing</button>
		<button id='disableMeshing'>Disable Meshing</button>
	</div>
	<div id='canvas'>
	</div>
  </body>
  <script src='js/three.js'></script>
  <script src='js/TrackballControls.js'></script>
  <script src="js/stats.min.js"></script>
  <script>
    var qualityElement = document.getElementById('quality');
	var accuracyElement = document.getElementById('accuracy');
	var startButton = document.getElementById('start');
	var resetButton = document.getElementById('reset');
	var stopButton = document.getElementById('stop');
	var enableTrackingButton = document.getElementById('enableTracking');
	var disableTrackingButton = document.getElementById('disableTracking');
	var enableMeshingButton = document.getElementById('enableMeshing');
	var disableMeshingButton = document.getElementById('disableMeshing');
	
	var sp = new xwalk.experimental.realsense.ScenePerception();
	sp.onchecking = function(e) {
		var quality = e.data.quality;
		qualityElement.innerHTML = 'Quality: ' + quality.toFixed(2);
	};

	sp.ontracking = function(e) {
		accuracyElement.innerHTML = 'Accuracy: ' + e.data.accuracy;
		if (e.data.accuracy == 'low' || e.data.accuracy == 'failed')
			return;
		updateCameraPose(e.data.cameraPose);
	};
	
	var meshesCreated = false;
	
	startButton.onclick = function(e) {
		sp.start().then(function(e) {console.log(e);});
	};
	
	resetButton.onclick = function(e) {
		meshesCreated = false;
		sp.reset().then(function(e) {console.log(e);});
	};
	
	stopButton.onclick = function(e) {
		sp.stop().then(function(e) {
			console.log(e);
			qualityElement.innerHTML = 'Quality: ';
		});	
	};
	
	enableTrackingButton.onclick = function(e) {
		sp.enableTracking().then(function(e) {console.log(e);});
	};
	
	disableTrackingButton.onclick = function(e) {
		sp.disableTracking().then(function(e) {
			console.log(e);
			accuracyElement.innerHTML = 'Accuracy: ';
		});
	};
	
	enableMeshingButton.onclick = function(e) {
		sp.enableMeshing().then(function(e) {console.log(e);});
	};
	
	disableMeshingButton.onclick = function(e) {
		sp.disableMeshing().then(function(e) {console.log(e);});
	};
	
	var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0xffffff, 1);
    renderer.setSize(640, 480);
    document.getElementById("canvas").appendChild(renderer.domElement);
	
	var stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.right = '0px';
	document.getElementById("canvas").appendChild(stats.domElement);
	
	var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 0, -3);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    var scene = new THREE.Scene();
	
	var controls = new THREE.TrackballControls(camera);

	var x_material = new THREE.LineBasicMaterial({
        color: new THREE.Color(1, 0, 0), linewidth: 4
    });
	
	var y_material = new THREE.LineBasicMaterial({
        color: new THREE.Color(0, 1, 0), linewidth: 4
    });
	
	var z_material = new THREE.LineBasicMaterial({
        color: new THREE.Color(0, 0, 1), linewidth: 4
    });
	
	var x_geometry = new THREE.Geometry();
    x_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    x_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
	
	var y_geometry = new THREE.Geometry();
    y_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    y_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
	
	var z_geometry = new THREE.Geometry();
    z_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    z_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
	
	var z_axis = new THREE.Line(z_geometry, z_material);
	var y_axis = new THREE.Line(y_geometry, y_material);
	var x_axis = new THREE.Line(x_geometry, x_material);

	scene.add(z_axis);
	scene.add(y_axis);
	scene.add(x_axis);

    animate();
	
	function render() {
		
        controls.update();
        renderer.render(scene, camera);
    }
	
	function poseMultiplyVect(out, pose, vect) {
		out.x = pose.elements[0]*vect.x + pose.elements[1]*vect.y + pose.elements[2]*vect.z + pose.elements[3]*vect.w;
		out.y = pose.elements[4]*vect.x + pose.elements[5]*vect.y + pose.elements[6]*vect.z + pose.elements[7]*vect.w;
		out.z = pose.elements[8]*vect.x + pose.elements[9]*vect.y + pose.elements[10]*vect.z + pose.elements[11]*vect.w;
		out.w = vect.w;
	}
	
	function updateCameraPose(cameraPoseArray) {
		var cameraPose = new THREE.Matrix4();
		cameraPose.set(cameraPoseArray[0], cameraPoseArray[1], cameraPoseArray[2], cameraPoseArray[3],
		               cameraPoseArray[4], cameraPoseArray[5], cameraPoseArray[6], cameraPoseArray[7],
					   cameraPoseArray[8], cameraPoseArray[9], cameraPoseArray[10], cameraPoseArray[11],
					   0, 0, 0, 0);
		var cameraCenter = new THREE.Vector3(cameraPose[3], cameraPose[7], cameraPose[11]);
		var cameraXAxis = new THREE.Vector4(0, 0, 0, 0);
		var xVect = new THREE.Vector4(0.16, 0.0, 0.0, 1.0);
		poseMultiplyVect(cameraXAxis, cameraPose, xVect);
		var cameraYAxis = new THREE.Vector4(0, 0, 0, 0);
		var yVect = new THREE.Vector4(0.0, 0.16, 0.0, 1.0);
		poseMultiplyVect(cameraYAxis, cameraPose, yVect);
		var cameraZAxis = new THREE.Vector4(0, 0, 0, 0);
		var zVect = new THREE.Vector4(0.0, 0.0, 0.16, 1.0);
		poseMultiplyVect(cameraZAxis, cameraPose, zVect);
		
		z_axis.geometry.dynamic = true;
		z_axis.geometry.vertices[0] = cameraCenter;
		z_axis.geometry.vertices[1] = new THREE.Vector3(cameraZAxis.x, cameraZAxis.y, cameraZAxis.z);
		z_axis.geometry.verticesNeedUpdate = true;
		
		y_axis.geometry.dynamic = true;
		y_axis.geometry.vertices[0] = cameraCenter;
		y_axis.geometry.vertices[1] = new THREE.Vector3(-cameraYAxis.x, -cameraYAxis.y, -cameraYAxis.z);
		y_axis.geometry.verticesNeedUpdate = true;
		
		x_axis.geometry.dynamic = true;
		x_axis.geometry.vertices[0] = cameraCenter;
		x_axis.geometry.vertices[1] = new THREE.Vector3(-cameraXAxis.x, -cameraXAxis.y, -cameraXAxis.z);
		x_axis.geometry.verticesNeedUpdate = true;
		
		//console.log(cameraCenter.x, cameraCenter.y, cameraCenter.z);
		//console.log(cameraXAxis.x, cameraXAxis.y, cameraXAxis.z);
	}
	
	var mesh = null, wire_mesh = null, wire_material = null;
	
	function updateMeshes(meshes) {
		if (meshes.length == 0)
			return;
		console.log(meshes.length);
		if (!meshesCreated) {
			meshesCreated = true;
		
			if (mesh) {
				scene.remove(mesh);
				scene.remove(wire_mesh);
			}
			var verticies = meshes[0].vertices;
			var faces = meshes[0].faces;
			var colors = meshes[0].colors;
			//console.log(verticies);
			//console.log(faces);
			console.log(colors);
			var geometry = new THREE.Geometry();
	        var elements = verticies.length / 3;
	        for (var i = 0; i < elements; i++) {
	            var index = i * 3;
	            geometry.vertices.push(new THREE.Vector3(verticies[index] * 100, verticies[index + 1]* 100, verticies[index + 2]* 100));
	        }
	        var elements = faces.length / 3;
	        for (var i = 0; i < elements; i++) {
	            var index = i * 3;
	            geometry.faces.push(new THREE.Face3(faces[index], faces[index + 1], faces[index + 2]));
	            var face = faces[index] * 3;
	            geometry.faces[i].vertexColors[0] =
	                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
	            var face = faces[index + 1] * 3;
	            geometry.faces[i].vertexColors[1] =
	                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
	            var face = faces[index + 2] * 3;
	            geometry.faces[i].vertexColors[2] =
	                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
	        }
	
			/*
	        var material = new THREE.MeshLambertMaterial(
            {
                color: 0xffffff, shading: THREE.SmoothShading,
                vertexColors: THREE.VertexColors, side: THREE.FrontSide,
                polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 4.0
            });
			*/
			var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors, side: THREE.BackSide,});
			geometry.computeFaceNormals();
	        mesh = new THREE.Mesh(geometry, material);
	        mesh.position.x = 0;
	        mesh.position.y = 0;
	        mesh.position.z = 0;
	        mesh.rotation.z += 180 * (Math.PI / 180);
	        mesh.rotation.y += 180 * (Math.PI / 180);
			
			wire_material = new THREE.MeshLambertMaterial(
            {
                color: 0xffffff, visible: true, wireframe: true, transparent: true, opacity: 0.15
            });
	        wire_mesh = new THREE.Mesh(geometry, wire_material);
	        wire_mesh.position.copy(mesh.position);
	        wire_mesh.rotation.copy(mesh.rotation);
	
	        scene.add(mesh);
			scene.add(wire_mesh);
		} else {
			
		}
	}
	
	function animate() {
	  requestAnimationFrame( animate );

	  render();
	  stats.update();
	}
  </script>
</html>