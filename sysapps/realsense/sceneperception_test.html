<html>
  <head>
    <title>ScenePerception Test</title>
  </head>
  <body>
    <p id='quality'>Quality: </p>
	<p id='accuracy'>Accuracy: </p>
	<div style='margin-bottom:23px;'>
		<button id='start'>Start</button>
		<button id='stop'>Stop</button>
		<button id='reset'>Reset</button>
		<button id='enableTracking'>Enable Tracking</button>
		<button id='disableTracking'>Disable Tracking</button>
		<button id='enableMeshing'>Enable Meshing</button>
		<button id='disableMeshing'>Disable Meshing</button>
	</div>
	<div id='canvas'>
	</div>
  </body>
  <script src='js/three.js'></script>
  <script src='js/TrackballControls.js'></script>
  <script src="js/stats.min.js"></script>
  <script>
    var qualityElement = document.getElementById('quality');
	var accuracyElement = document.getElementById('accuracy');
	var startButton = document.getElementById('start');
	var resetButton = document.getElementById('reset');
	var stopButton = document.getElementById('stop');
	var enableTrackingButton = document.getElementById('enableTracking');
	var disableTrackingButton = document.getElementById('disableTracking');
	var enableMeshingButton = document.getElementById('enableMeshing');
	var disableMeshingButton = document.getElementById('disableMeshing');
	
	var blockMeshMap = {};
	var totalMesh = null;
	var totalMaterials;
	var totalGeom;
	
	var scene;
	
	var sp = new xwalk.experimental.realsense.ScenePerception();
	sp.onchecking = function(e) {
		var quality = e.data.quality;
		qualityElement.innerHTML = 'Quality: ' + quality.toFixed(2);
	};

	sp.ontracking = function(e) {
		accuracyElement.innerHTML = 'Accuracy: ' + e.data.accuracy;
		updateCameraPose(e.data.cameraPose, e.data.accuracy);
	};
	sp.onmeshing = function(e) {
		console.log(e.data);
		var func = updateMeshes2.bind(this, e.data);
		setTimeout(func, 0);
	};
	
	var meshesCreated = false;
	
	startButton.onclick = function(e) {
		sp.start().then(function(e) {console.log(e);});
	};
	
	resetButton.onclick = function(e) {
		sp.reset().then(function(e) {console.log(e);});
		removeAllMeshes();
	};
	
	function removeAllMeshes() {
		for (var id in blockMeshMap) {
			scene.remove(blockMeshMap[id]);
			delete blockMeshMap[id];
		}
		if (totalMesh)
			scene.remove(totalMesh);
		delete totalMesh;
		totalMesh = null;
	}
	
	stopButton.onclick = function(e) {
		sp.stop().then(function(e) {
			console.log(e);
			qualityElement.innerHTML = 'Quality: ';
		});
	};
	
	enableTrackingButton.onclick = function(e) {
		sp.enableTracking().then(function(e) {console.log(e);});
	};
	
	disableTrackingButton.onclick = function(e) {
		sp.disableTracking().then(function(e) {
			console.log(e);
			accuracyElement.innerHTML = 'Accuracy: ';
			showCamera(false);
		});
	};
	
	enableMeshingButton.onclick = function(e) {
		sp.enableMeshing().then(function(e) {console.log(e);});
	};
	
	disableMeshingButton.onclick = function(e) {
		sp.disableMeshing().then(function(e) {console.log(e);mergeMeshes();});
	};
	
	var timeout = null;
	
	function mergeMeshes() {
		if (blockMeshMap.length == 0)
			return;
		console.time("mergeMeshes");
		totalMaterials = [];
    	totalGeom = new THREE.Geometry();
		for (var id in blockMeshMap) {
			//scene.remove(blockMeshMap[id]);
			var m = blockMeshMap[id];
			m.updateMatrix();
			totalGeom.merge(m.geometry, m.matrix);
			totalMaterials.push(m.material);
			//scene.remove(m);
			//delete blockMeshMap[id];
		}
		if (totalMesh)
			scene.remove(totalMesh)
		totalMesh = new THREE.Mesh(totalGeom, new THREE.MeshFaceMaterial(totalMaterials));
    	scene.add(totalMesh);
		timeout = null;
		console.timeEnd("mergeMeshes");
	};

	
	var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0x000000, 1);
    renderer.setSize(640, 480);
    document.getElementById("canvas").appendChild(renderer.domElement);
	
	var stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.right = '0px';
	document.getElementById("canvas").appendChild(stats.domElement);
	
	var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 0, 3);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    scene = new THREE.Scene();
	
	var controls = new THREE.TrackballControls(camera);

	var x_material = new THREE.LineBasicMaterial({
        color: new THREE.Color(1, 0, 0), linewidth: 4
    });
	
	var y_material = new THREE.LineBasicMaterial({
        color: new THREE.Color(0, 1, 0), linewidth: 4
    });
	
	var z_material = new THREE.LineBasicMaterial({
        color: new THREE.Color(0, 0, 1), linewidth: 4
    });
	
	var x_geometry = new THREE.Geometry();
    x_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    x_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
	
	var y_geometry = new THREE.Geometry();
    y_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    y_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
	
	var z_geometry = new THREE.Geometry();
    z_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    z_geometry.vertices.push(new THREE.Vector3(0, 0, 0));
	
	var z_axis = new THREE.Line(z_geometry, z_material);
	var y_axis = new THREE.Line(y_geometry, y_material);
	var x_axis = new THREE.Line(x_geometry, x_material);

	scene.add(z_axis);
	scene.add(y_axis);
	scene.add(x_axis);

    animate();
	
	function render() {
		
        controls.update();
        renderer.render(scene, camera);
    }
	
	function poseMultiplyVect(out, pose, vect) {
		out.x = pose[0]*vect.x + pose[1]*vect.y + pose[2]*vect.z + pose[3]*vect.w;
		out.y = pose[4]*vect.x + pose[5]*vect.y + pose[6]*vect.z + pose[7]*vect.w;
		out.z = pose[8]*vect.x + pose[9]*vect.y + pose[10]*vect.z + pose[11]*vect.w;
		out.w = vect.w;
	}
	
	function showCamera(show) {
		x_axis.material.visible = show;
		y_axis.material.visible = show;
		z_axis.material.visible = show;
	}
	
	function updateCameraPose(cameraPoseArray, accuracy) {
		if (accuracy == 'low' || accuracy == 'failed') {
			showCamera(false);
			return;
		} else {
			showCamera(true);
		}
		cameraPoseArray[7] = -cameraPoseArray[7];
		var cameraCenter = new THREE.Vector3(cameraPoseArray[3], cameraPoseArray[7], cameraPoseArray[11]);
		var cameraXAxis = new THREE.Vector4(0, 0, 0, 0);
		var xVect = new THREE.Vector4(0.16, 0.0, 0.0, 1.0);
		poseMultiplyVect(cameraXAxis, cameraPoseArray, xVect);
		var cameraYAxis = new THREE.Vector4(0, 0, 0, 0);
		var yVect = new THREE.Vector4(0.0, 0.16, 0.0, 1.0);
		poseMultiplyVect(cameraYAxis, cameraPoseArray, yVect);
		var cameraZAxis = new THREE.Vector4(0, 0, 0, 0);
		var zVect = new THREE.Vector4(0.0, 0.0, 0.16, 1.0);
		poseMultiplyVect(cameraZAxis, cameraPoseArray, zVect);
		
		z_axis.geometry.dynamic = true;
		z_axis.geometry.vertices[0] = cameraCenter;
		z_axis.geometry.vertices[1] = new THREE.Vector3(cameraZAxis.x, cameraZAxis.y, cameraZAxis.z);
		z_axis.geometry.verticesNeedUpdate = true;
		
		y_axis.geometry.dynamic = true;
		y_axis.geometry.vertices[0] = cameraCenter;
		y_axis.geometry.vertices[1] = new THREE.Vector3(cameraYAxis.x, cameraYAxis.y, cameraYAxis.z);
		y_axis.geometry.verticesNeedUpdate = true;
		
		x_axis.geometry.dynamic = true;
		x_axis.geometry.vertices[0] = cameraCenter;
		x_axis.geometry.vertices[1] = new THREE.Vector3(cameraXAxis.x, cameraXAxis.y, cameraXAxis.z);
		x_axis.geometry.verticesNeedUpdate = true;
		
		//console.log(cameraCenter.x, cameraCenter.y, cameraCenter.z);
		//console.log(cameraXAxis.x, cameraXAxis.y, cameraXAxis.z);
	}
	
	function updateMeshes(meshes) {
		console.time('updateMeshes');
		var verticies = new Float32Array(meshes.vertices, 0, meshes.numberOfVertices * 4);
		console.log('meshes.vertices: ' + meshes.vertices.byteLength);
		console.log('meshes.numberOfVertices: ' + meshes.numberOfVertices);
		console.log('vertices: ' + verticies.length);
		var colors = new Uint8Array(meshes.colors, 0, meshes.numberOfVertices * 3);
		console.log('meshes.colors: ' + meshes.colors.byteLength);
		console.log('colors: ' + colors.length);
		var faces = new Int32Array(meshes.faces, 0, meshes.numberOfFaces * 3);
		console.log('meshes.faces: ' + meshes.faces.byteLength);
		console.log('meshes.numberOfFaces: ' + meshes.numberOfFaces);
		console.log('faces: ' + faces.length);
		var geometry = new THREE.Geometry();
        var elements = verticies.length / 4;
        for (var i = 0; i < elements; i++) {
            var index = i * 4;
            geometry.vertices.push(new THREE.Vector3(verticies[index], verticies[index + 1], verticies[index + 2]));
        }
        var elements = faces.length / 3;
        for (var i = 0; i < elements; i++) {
            var index = i * 3;
            geometry.faces.push(new THREE.Face3(faces[index], faces[index + 1], faces[index + 2]));
            var face = faces[index] * 3;
            geometry.faces[i].vertexColors[0] =
                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
            var face = faces[index + 1] * 3;
            geometry.faces[i].vertexColors[1] =
                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
            var face = faces[index + 2] * 3;
            geometry.faces[i].vertexColors[2] =
                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
        }

		/*
        var material = new THREE.MeshLambertMaterial(
        {
            color: 0xffffff, shading: THREE.SmoothShading,
            vertexColors: THREE.VertexColors, side: THREE.FrontSide,
            polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 4.0
        });
		*/
		var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors, side: THREE.BackSide,});
		geometry.computeFaceNormals();
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = 0;
        mesh.position.y = 0;
        mesh.position.z = 0;
        mesh.rotation.z += 180 * (Math.PI / 180);
        mesh.rotation.y += 180 * (Math.PI / 180);

        scene.add(mesh);
		console.timeEnd('updateMeshes');
	};
	
	function updateMeshes2(meshes) {
		console.time('updateMeshes2');
		var verticies = new Float32Array(meshes.vertices, 0, meshes.numberOfVertices * 4);
		var colors = new Uint8Array(meshes.colors, 0, meshes.numberOfVertices * 3);
		var faces = new Int32Array(meshes.faces, 0, meshes.numberOfFaces * 3);
		var blockMeshes = meshes.blockMeshes;
		console.log('blockMeshes.length: ' + blockMeshes.length);
		for (var j = 0; j < blockMeshes.length; ++j) {
			var blockMesh = blockMeshes[j];
			if (blockMesh.numVertices == 0 || blockMesh.numFaces == 0)
				continue;
			if (blockMesh.meshId in blockMeshMap) {
				//scene.remove(blockMeshMap[blockMesh.meshId]);
				delete blockMeshMap[blockMesh.meshId];
			}
			var geometry = new THREE.Geometry();
			//console.log('mesh: ' + j + ' numVertices: ' + blockMesh.numVertices + ' numFaces: ' + blockMesh.numFaces);
	        var elements = blockMesh.numVertices;
			var vertexStartIndex = blockMesh.vertexStartIndex;
	        for (var i = 0; i < elements; i++) {
	            var index = i * 4;
	            geometry.vertices.push(new THREE.Vector3(verticies[vertexStartIndex + index], verticies[vertexStartIndex + index + 1], verticies[vertexStartIndex + index + 2]));
	        }
	        var elements = blockMesh.numFaces;
			var faceStartIndex = blockMesh.faceStartIndex;
	        for (var i = 0; i < elements; i++) {
	            var index = i * 3;
				var vertexOffset = vertexStartIndex / 4;
	            geometry.faces.push(new THREE.Face3(faces[faceStartIndex + index] - vertexOffset, faces[faceStartIndex+ index + 1] - vertexOffset, faces[faceStartIndex + index + 2] - vertexOffset));
	            var face = faces[faceStartIndex + index] * 3;
	            geometry.faces[i].vertexColors[0] =
	                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
	            var face = faces[faceStartIndex + index + 1] * 3;
	            geometry.faces[i].vertexColors[1] =
	                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
	            var face = faces[faceStartIndex + index + 2] * 3;
	            geometry.faces[i].vertexColors[2] =
	                new THREE.Color("rgb(" + colors[face] + "," + colors[face+1] + "," + colors[face+2] + ")");
	        }
	
			var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors, side: THREE.BackSide,});
			geometry.computeFaceNormals();
	        var mesh = new THREE.Mesh(geometry, material);
	        mesh.position.x = 0;
	        mesh.position.y = 0;
	        mesh.position.z = 0;
	        mesh.rotation.z += 180 * (Math.PI / 180);
	        mesh.rotation.y += 180 * (Math.PI / 180);
			var wire_material = new THREE.MeshLambertMaterial(
            {
                color: 0xffffff, visible: true, wireframe: true, transparent: true, opacity: 0.15
            });
	        var wire_mesh = new THREE.Mesh(geometry, wire_material);
	        wire_mesh.position.x = 0;
	        wire_mesh.position.y = 0;
	        wire_mesh.position.z = 0;
	        wire_mesh.rotation.z += 180 * (Math.PI / 180);
	        wire_mesh.rotation.y += 180 * (Math.PI / 180);
	
	        //scene.add(mesh);
			blockMeshMap[blockMesh.meshId] = mesh;
			
			//scene.add(wire_mesh);
			//blockMeshMap[blockMesh.meshId] = wire_mesh;
		}
		
		if (timeout === null) {
			timeout = setTimeout(mergeMeshes, 250);
		}
		console.timeEnd('updateMeshes2');
	}
	
	function animate() {
	  requestAnimationFrame( animate );

	  render();
	  stats.update();
	}
  </script>
</html>